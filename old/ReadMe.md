### Rexjs 的各个时期重大的变更版本

#### rex-1.0.js
- 解析方案：正则

- 解析原理：先将所有括号用 \数字 包括，如：{{}} 将会被替换成 \0{\0\1{\1\1}\1\0}\0，然后在之后的正则里就可以通过同一数字所包括的括号来确定其对应的另一个括号。

#### rex-2.0.js
- 解决方案：正则

- 解析原理：单功能处进行正则匹配，匹配成功后，将源代码截取，留下未匹配的源代码片段

#### rex-3.0.js
- 解决方案：正则 + 元素 + 非元素性质的自定义事件

- 解析原理：先用注册标签，合并标签正则，对整个源代码进行匹配，生成一个文档树，然后再使用 TreeWalker 对元素进行访问，并触发对应标签事件。事件处理器中，会对源代码上下文进行检验，而检验时会利用到 node 的一些方法，如一个计算式名称元素可以使用“+bracket+parenthesis+brace”，来确定是否是完整的计算式属性

- 备注：就算是使用 dom 相关 API，性能还是非常的好，在源代码少的时候，比现有较流行的解析器的那种字符解析还要快，但有个分水岭，即2万源代码以下，这种元素解析更快，2万行源代码左右，则差不多，超过2万行，速度稍微慢一些，当然，这是 2016 年所测试的数据

#### rex-4.0.js
- 解决方案：正则 + 元素 + 非元素性质的自定义事件

- 解析原理：先用注册标签，合并标签正则，使用 RegExp.prototype.exec 与 RegExp.prototype.lastIndex 来解析源代码，匹配到一个就触发对应标签所绑定的事件，然后在绑定事件中对上下文关系进行其他事件监听

- 备注：由于不好解析 ASI 机制而废弃

#### rex-es-5.0.js 及 以后版本
- 解决方案：正则 + 语法标签 + 语法表达式 + 语法语句 + 语法语句块等等

- 解析原理：根据最初的标签列表所关联的正则，去匹配源代码，从而获取到对应语法标签，而该语法标签又会返回下一个它自己所需关联的上下文标签列表，如此重复，直至匹配完所有源代码