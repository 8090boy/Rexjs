+ generator
+ 对象解构赋值
+ 数组解构赋值
+ 将模块重命名或设置别名：rename 或 alias，将复杂的"../../a.js"记录成"a"
+ get、set：value
+ let、const的错误提示
+ override
+ ECMAScript6Parser.getSeparatorElement 逻辑

- 模块化
- 枚举、接口：参考对象语法
- 语法依赖提醒，ECMAScript6Parser.deps
- super、get等关键字只在对应作用域内解析成元素，其他情况一律视为文本节点
- 对象属性名称中不解析 this、var等关键字，如 var a = { this : 1 };
- assgin：参考export语法
- 模板
- .this等属性当做普通文本
- for of的完善
- 函数传参的rest参数解析


q : 为什么采用DOM形式解析新语法？
a : 因为DOM身为浏览器核心且是一种“高效”、“完整”、“功能强大”的一种数据类型，最重要的是“大家都会操作DOM”。
	- 高效：适者生存，身为浏览器核心功能，如果效率跟不上时代的步伐，只能像老版本IE一样，被人唾弃；
	- 完整：DOM有一套完整的关系网，从EventTarget 到 TextNode、HTMLElement等，甚至到 TreeWalker、Selection、Range 等，无一不是关系密切；
	- 功能强大：完整的关系网，也给DOM带来了一系列强大的API支持，基本的增删改查，到DOM属性、DOM特性、DOM文档位置等等等，以及他们之间的关系，一个个都由浏览器实现了；

q : 为什么要事件不采用DOM事件模式？
a : DOM事件模式不适合语法解析：
	1. DOM事件会冒泡，语法解析基本用不到冒泡，再者每个事件都提供了next参数，事件监听不一定需要写死监听顺序，使用next参数控制更为方便
	2. DOM事件会将所有监听器都触发，语法解析不需要将所有监听器都触发，并提供有next这种触发下一个同类型的函数，而且触发所有监听将会比较耗性能
	3. 语法解析有着明确性，基本上大部分符号在所处位子表达的意思是唯一的，如：var obj = {}; 与 if(true){};中的2对大括号，当它成为了对象，就不可能为if的语句块。
	4. 即使少数同一符号所处意思一致，那么则必须按顺序添加解析器，
		如：function fn(a = 1){}; 与 function fn({a} = { a : 1 }){};中的2个小括号，
			第一个是“默认值参数”解析器；
			第二个是“解构默认值参数”解析器；
		两个代码都需要监听小括号，而小括号所表达的意思且一致，那么你必须明白解析器的依赖性，即第二个解析器依赖第一个解析器，
		所以第二个解析器要在第一个解析器后进行添加到SyntaxTree的实例中，并需要在第二个解析器里使用next函数触发第一个解析器的监听器。

q : 什么时候使用 appendElement、appendText？
a : 所需添加的代码，需要依赖其他解析器（其他监听器一般是对元素进行监听和判断）的情况下，可以使用 appendElement，其他情况均使用 appendText。
	如箭头函数的解析：
		源代码：var fn = (x) => true;
		解析后：var fn = function(x){ return (true); };
		
		其中，"function"、"{"、"}" 这3段代码应该被解析成元素，因为函数解析器依赖这3个元素；
		而 "return (" 与 ");" 这2段代码，不应该被解析成元素，因为它不依赖其他解析器；
		如果乱添加元素，会导致源代码元素解构错乱和逻辑判断错误，如上面的小括号如果被解析成元素，那么ASI机制判断小括号内是不会自动插入分号，
		从而监听不到应有的事件，这是不满足我们的需求的。